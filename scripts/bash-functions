#!/bin/bash

#######################################
# Cleanup files from the backup dir
# Globals:
#   None
# Arguments:
#   None
# Returns:
#   == 0 => pg1 is ACTIVE; != 0 => pg1 is not ACTIVE
#######################################
is-pg1-active () {
	docker exec -it pg1 sh -c 'psql -c "select version();" -U postgres; exit $?;' &>/dev/null
	return $?
}

#######################################
# Cleanup files from the backup dir
# Globals:
#   None
# Arguments:
#   None
# Returns:
#   == 0 => pg2 is ACTIVE; != 0 => pg2 is not ACTIVE
#######################################
is-pg2-active () {
	docker exec -it pg2 sh -c 'psql -c "select version();" -U postgres; exit $?;' &>/dev/null
	return $?
}

#######################################
# Cleanup files from the backup dir
# Globals:
#   Exports $ACTIVE_PG and $STANDBY_PG if either is ACTIVE
# Arguments:
#   None
# Returns:
#   None
#######################################
pg-status () {
    
    if is-pg1-active; then
        local pg1_STATE='ACTIVE'
    elif is-pg1-standby; then
        local pg1_STATE='STANDBY'
    elif container-exists pg1; then
        local pg1_STATE='STOPPED'
    else
        local pg1_STATE='GONE'
    fi;

    if is-pg2-active; then
        local pg2_STATE='ACTIVE'
    elif is-pg2-standby; then
        local pg2_STATE='STANDBY'
    elif container-exists pg2; then
        local pg2_STATE='STOPPED'
    else
        local pg2_STATE='GONE'
    fi;

    if [ $pg1_STATE == 'ACTIVE' ]; then
        ACTIVE_PG='pg1'
        STANDBY_PG='pg2'
    elif [ $pg2_STATE == 'ACTIVE' ]; then
        ACTIVE_PG='pg2'
        STANDBY_PG='pg1'
    else  # If neither, then unset both
        unset ACTIVE_PG
        unset STANDBY_PG
    fi;

    msg 'pg1: '$pg1_STATE', pg2: '$pg2_STATE
}

is-pg1-standby () {
	docker exec -it pg1 sh -c 'psql -c "select version();" -p 5433 -U postgres; exit $?;' &>/dev/null
	return $?
}

is-pg2-standby () {
	docker exec -it pg2 sh -c 'psql -c "select version();" -p 5433 -U postgres; exit $?;' &>/dev/null
	return $?
}

msg () {
	echo "${PROGNAME}: ${1:-"Message Not Provided"}" 1>&2
}

change-pgdata-owner () {
    
    if ! docker exec -it barman sh -c 'chown -R '$1'.'$1' /'$2'_data; exit $?;'; then 
        func-error $FUNCNAME $LINENO 'PGDATA Ownership Change Failed';
        return 1
    fi
    return 0
}

change-pgdata-permissions () {

    if ! docker exec -it barman sh -c 'chmod -R 775 /'$1'_data; exit $?;' &> /dev/null; then 
        func-error $FUNCNAME $LINENO 'PGDATA Permissions Change Failed';
        return 1
    fi
    return 0
}

# Define the environment (DEV, QA, or PROD)
# If no parameter provided, then it is a request to diplay the current environment
tcsenv () {
    local USAGE='Usage: tcsenv [dev|qa|prod]'

    if [ "$#" == 0 ]; then
        echo $TCSENV
        return 0
    elif [ "$#" == 1 ]; then
        case "$1" in
            [dD][eE][vV])
                export COMPOSE_ARGS=$DEV_COMPOSE_ARGS
                export TCSENV=dev
                ;;
            [qQ][aA])
                export COMPOSE_ARGS=$QA_COMPOSE_ARGS
                export TCSENV=qa
                ;;
            [pP][rR][oO][dD])
                export COMPOSE_ARGS=$PROD_COMPOSE_ARGS
                export TCSENV=prod
                ;;
            *) echo $USAGE
                return 1
                ;;
        esac
        echo $TCSENV
        return 0
    else
        echo $USAGE
    fi
}

# Ensure that a container is not restarted at boot time
disable-restart () {
    docker update --restart no $1 2>&1 >/dev/null
    return $?
}

# Configure the container to auto restart in the case of a reboot
enable-restart () {
    
    if docker update --restart unless-stopped $1 2>&1 >/dev/null; then 
        return 0
    else 
        func-error $FUNCNAME $LINENO 'Unable to Reconfigure '$1' Container to Auto Restart'; 
        return 1;  
    fi
}

alter-archive-command () {
        
    for i in {1..10}
    do
        sleep 2
        if ! docker exec -it $1 sh -c 'psql -c "ALTER SYSTEM SET archive_command TO true;" -U postgres; exit $?;' &> /dev/null; then 
            func-error $FUNCNAME $LINENO $1' Failed to Alter archive_command';
            continue
        fi
        
        if ! docker exec -it $1 sh -c 'psql -c "SELECT pg_reload_conf();" -U postgres 2>&1 >/dev/null; exit $?;' &> /dev/null; then 
            func-error $FUNCNAME $LINENO $1' Failed to Reload Postgres';
            continue
        fi
        return 0
    done
    func-error $FUNCNAME $LINENO $1' Unable to Alter archive_command';
    return 1
}

enable-barman-backups () {

    echo -n $PROGNAME': Enable Backups ... '
    # Various steps to ensure that barman is backing up the ACTIVE pg
    pg-status &> /dev/null
    barman-create-slot $ACTIVE_PG;
    if ! barman-reset $ACTIVE_PG; then return 1; fi
    if ! barman-cron; then return 1; fi
    if ! barman-check $ACTIVE_PG; then return 1; fi
    echo 'done'
    return 0
}

error-exit () {

	# Display error message and exit
	msg "${1:-"Unknown Error"}" 1>&2
    msg 'Aborted'
	exit 1
}

func-error () {
    msg 'Error in function: '$1', Line '$2': '"$3"
}

barman-check () {
	
    if [ $# != 1 ]; then func-error $FUNCNAME $LINENO 'Incorrect parameter count'; return 1; fi

    for i in {1..10}
    do
        sleep 2
        if docker exec -it barman sh -c 'ps -ef | grep pg_receivexlog | grep -v grep; exit $?;' &> /dev/null; then
            return 0
        fi
    done

    # If barman configuration fails, report why
    docker exec -it barman sh -c 'barman check '$1'; exit $?;'
    msg $1' Stream Replication Activation Failed';
    return 1
}

barman-create-slot () {
	docker exec -it barman sh -c 'barman receive-wal --create-slot '$1'; exit $?;' &> /dev/null
}

barman-cron () {
	docker exec -it barman sh -c 'barman cron 2>&1 >/dev/null; exit $?;'
	return $?
}

barman-recover-latest () {

    echo -n $PROGNAME': Backup (latest) Recovery to '$2' ... '

    # barman needs ownership of the pgdata area
    if ! change-pgdata-owner barman $2; then return 1; fi

    # Tweak unix permissions
    if ! change-pgdata-permissions $2; then return 1; fi

    # Use barman to recover the latest backup for the selected pg container
    docker exec -it barman sh -c 'barman recover '$1' latest /'$2'_data 2>&1 >/dev/null; exit $?;'
    if [ $? != 0 ]; then 
        func-error $FUNCNAME $LINENO  $2' Recovery Failure';
        return 1
    fi

    # Ownership now passed to postgres
    if ! change-pgdata-owner postgres $2; then return 1; fi
    echo 'done'
    return 0
}

barman-recover () {
    
    echo -n $PROGNAME': Backup (latest) Recovery to '$2' ... '

    # barman needs ownership of the pgdata area
    if ! change-pgdata-owner barman $1; then return 1; fi

    # Tweak unix permissions
    change-pgdata-permissions $1

    # Do the recovery
    if [ "$#" == 2 ]; then
        docker exec -it barman sh -c 'barman recover '$1' '$2' /'$1'_data 2>&1 >/dev/null; exit $?;'
        if [ $? != 0 ]; then 
            func-error $FUNCNAME $LINENO $1' Recovery Failure';
            return 1
        else 
            msg $1' Recovery Successful'; 
        fi
    elif [ "$#" == 3 ]; then
        if ! docker exec -it barman sh -c 'barman recover '$2' '$3' /'$1'_data 2>&1 >/dev/null; exit $?;'; then
            func-error $FUNCNAME $LINENO  $1' Recovery Failure';
            return 1
        fi
    else
        func-error $FUNCNAME $LINENO 'Incorrect number of parameters'
    fi

    # Ownership now passed to postgres
    if ! change-pgdata-owner postgres $2; then return 1; fi
    echo 'done'
    return 0   
}

barman-clear-legacy-streaming () {
    if ! docker exec -it barman sh -c 'rm -rf /var/lib/barman/'$1'/streaming/*; exit $?;'; then
        func-error $FUNCNAME $LINENO 'Unable to clear legacy streaming';
        return 1
    fi
}

barman-pitr () {

    echo -n $PROGNAME': Point-In-Time Recovery to '$1' ... '

    if [ "$#" != 3 ] && [ "$#" != 4 ] ; then func-error $FUNCNAME $LINENO 'Incorrect number of parameters'; return 1; fi

    # barman needs ownership of the pgdata area
    if ! change-pgdata-owner barman $1; then return 1; fi

    # Tweak unix permissions
    if ! change-pgdata-permissions $1; then return 1; fi

    # Do the recovery
    case "$#" in
        3) if ! docker exec -it barman sh -c 'barman recover --target-time '$3' '$1' '$2' /'$1'_data 2>&1 >/dev/null; exit $?;'; then
            return 1
            fi
            ;;
        4) if ! docker exec -it barman sh -c 'barman recover --target-time '$4' '$2' '$3' /'$1'_data 2>&1 >/dev/null; exit $?;'; 
            then return 1; fi
            ;;
        *)  func-error $FUNCNAME $LINENO 'Assertion Error'
            return 1
            ;;
    esac

    # Ownership passed to postgres
    if ! change-pgdata-owner postgres $1; then return 1; fi
    echo 'done'
    return 0
}

barman-reset () {
	if ! docker exec -it barman sh -c 'barman receive-wal --reset '$1'; exit $?;' &> /dev/null; then
        msg $1' Failed to Reset Stream Replication';      
    fi
}

container-exists () {
    docker inspect --format='{{.State.Running}}' $1 &> /dev/null
    return $?
}

confirm-barman () {
    # Minimally barman must be running
    if [ ! docker inspect --format='{{.State.Running}}' barman &> /dev/null ]; then 
        func-error $FUNCNAME $LINENO 'barman GONE'
        return 1
    fi

    barman_running=$(docker inspect --format='{{.State.Running}}' barman)
    if [ "$barman_running" == "false" ]; then 
        func-error $FUNCNAME $LINENO 'barman Not Running'
        return 1; 
    fi

    return 0
}

remove-core-container () {
	# If there is no such container, then nothing to do
    if container-exists $1; then
        echo -n $PROGNAME': Removing Container '$1' ... '
        docker stop --time 10 $1 2>&1 >/dev/null
	    docker-compose $CORE_COMPOSE_ARGS rm -f -v $1 &> /dev/null
        echo 'done'
    fi
}

set-pg-ports () {
    if [ $1 == 'pg1' ]; then
	    echo 'export PG1_PORT=5432; export PG2_PORT=5433;' > .tcs-pg-ports
        return 0
    elif [ $1 == 'pg2' ]; then
	    echo 'export PG1_PORT=5433; export PG2_PORT=5432;' > .tcs-pg-ports
        return 0
    else
        func-error $FUNCNAME $LINENO 'Invalid pg Selection '$1
        return 1;
    fi
}

start-container () {
    if ! docker start $1 2>&1 >/dev/null; then return 1; fi

    enable-restart $1
    return $?
}

start-core-container () {
    echo -n $PROGNAME': Starting '$1' ... '
    
    source ./.tcs-pg-ports
    if ! docker-compose $CORE_COMPOSE_ARGS up -d $1 &> /dev/null; then
        return 1
    fi

    if enable-restart $1; then echo 'done'; return 0; else return 1; fi
}

start-pg-container () {

    source ./.tcs-pg-ports
    # Ensure Postgres owns everything
    if ! change-pgdata-owner postgres $1; then exit 1; fi

    # Now start the incoming Postgres container
    if ! start-core-container $1; then error-exit 'Failed to Start Container '$1; fi

    if ! alter-archive-command $1; then exit 1; fi

    if ! barman-clear-legacy-streaming $1; then exit 1; fi

    if ! enable-barman-backups; then exit 1; fi

    return 0;
}

validate-pg-selection () {
    if [ "$1" != 'pg1' ] && [ "$1" != 'pg2' ]; then
        # $2 is the $USAGE
        error-exit "$2"
    fi
}

validate-backup_id () {
    if ! docker exec -it barman sh -c 'barman list-backup --minimal '$1' | grep -w '$2'; exit $?;' &> /dev/null; then 
        error-exit 'Unknown '$1' backup_id '$2; 
    fi
}
